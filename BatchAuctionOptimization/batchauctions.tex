\documentclass[11pt,parskip=full]{scrartcl}%article}
%\setlength{\parskip}{1em}

%%%%%%%%%%%%%%%%%%%%%%
%% PACKAGE INCLUDES %%
%%%%%%%%%%%%%%%%%%%%%%

\usepackage{array}           % For defining \newcolumntype.
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}          % Provides 'proof' environment.
\usepackage[english]{babel}  % For defining 'theorem/corollary/lemma' environments.
\usepackage{bm}              % Provides bold \pi
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{todonotes}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{caption}         % For subtables.
\usepackage{subcaption}      % For subtables.
%\usepackage{subfig}
\usepackage{comment}


%%%%%%%%%%%%%%%%%
%% STYLE SETUP %%
%%%%%%%%%%%%%%%%%

% Define some custom colors.
\definecolor{mylinkcolor}{RGB}{000, 114, 166}
\definecolor{mycitecolor}{RGB}{255, 154, 071}
\definecolor{myurlcolor}{RGB}{000, 114, 166}

% Set itemize format.
\setitemize{noitemsep,topsep=-5pt,parsep=5pt,partopsep=0pt}

% Define column types that allow fixed width params.
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Color setup for hyperlinks/references/citations/urls.
\hypersetup{
    colorlinks,
    linkcolor={mylinkcolor},
    citecolor={mycitecolor},
    urlcolor={myurlcolor}
}

% Specify hyphenation of words on line break.
\hyphenation{Figure Table Chapter Section}



%%%%%%%%%%%%
%% MACROS %%
%%%%%%%%%%%%

% Set default font family to sans-serif.
\renewcommand*{\familydefault}{\sfdefault}

\newcommand*{\ie}{i.e., }
\newcommand*{\eg}{e.g., }
\newcommand*{\wrt}{with respect to }

\newcommand*{\Min}{\mathrm{min}}
\newcommand*{\Max}{\mathrm{max}}

\newcommand*{\tokens}{\mathcal{T}}          % Set of tokens.
\newcommand*{\orders}{\mathcal{O}}          % Set of orders.
\newcommand*{\buyorders}{\mathcal{O}^b}     % Set of buy orders.
\newcommand*{\sellorders}{\mathcal{O}^s}    % Set of sell orders.
\newcommand*{\itokens}{\mathcal{I}^t}       % Set of token indices.
\newcommand*{\itokenpairs}{\mathcal{I}^p}   % Set of token index pairs.
\newcommand*{\iutokenpairs}{\tilde{\mathcal{I}}^p}   % Set of token index pairs.
\newcommand*{\iorders}{\mathcal{I}^o}       % Set of order indices.
\newcommand*{\ibuyorders}{\mathcal{I}^b}    % Set of buy order indices.
\newcommand*{\isellorders}{\mathcal{I}^s}   % Set of sell order indices.

% Macros for references etc.
\newcommand*{\figref}[1]{\hyperref[{#1}]{Figure~\ref*{#1}}}
\newcommand*{\tabref}[1]{\hyperref[{#1}]{Table~\ref*{#1}}}
\newcommand*{\secref}[1]{\hyperref[{#1}]{Section~\ref*{#1}}}
\newcommand*{\subsecref}[1]{\hyperref[{#1}]{Section~\ref*{#1}}}
\newcommand*{\thmref}[1]{\hyperref[{#1}]{Theorem~\ref*{#1}}}
\newcommand*{\crlref}[1]{\hyperref[{#1}]{Corollary~\ref*{#1}}}
\newcommand*{\lemref}[1]{\hyperref[{#1}]{Lemma~\ref*{#1}}}

% Macros for theorems|corollaries|lemmas|observations.
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{observation}[theorem]{Observation}

%%%%%%%%%%%%%%
%% DOCUMENT %%
%%%%%%%%%%%%%%

\title{
  Multi-token Batch Auctions with Uniform Clearing Prices\\
  - \\
  \Large Features and Models}
\author{Tom Walther \\ tom@gnosis.pm}

\date{\today}



\begin{document}

\maketitle


\begin{abstract}
  This document describes the problem of multi-token batch auctions with uniform clearing prices as
  a price-finding mechanism proposed for a decentralized token trading platform.
  Moreover, it contains solution approaches based on combinatorial optimization formulations, as
  well as some computational results.
%\footnote{... footnote ...}.
\end{abstract}

%\todo[inline,caption={}]{
%  \begin{itemize}
%    \item computational results for MIP\{2|3\}
%  \end{itemize}
%}


\tableofcontents

\newpage
\section{Introduction}
\label{sec:introduction}

In continuous-time token exchange mechanisms, orders are typically collected in order books of two
tokens that are traded against each other.
A trade happens whenever a buy order of one token is matched by a sell order of the other, \ie if
there exists an exchange rate that satisfies the limit prices stated in the respective orders.
In a setting of multiple tradeable tokens, one separate order book is required for every token pair
combination.
This may significantly limit liquidity for less frequently traded token pairs and lead to large
bid-ask spreads and low trading volumes.

In our approach, we want to collect orders for a set of multiple tokens in a single joint order
book and compute exchange prices for all token pairs simultaneously at the end of discrete time
intervals (\emph{multi-token batch auction}).
Trades between the same token pairs are then all executed at the same exchange rate (\emph{uniform
clearing price}).
Moreover, this mechanism enables so-called \emph{ring trades}, where orders are matched along
cycles of tokens.
In order to exclude arbitrage opportunities, we require prices to be consistent along such cycles,
\ie we want the constraint
\begin{align}
  p_{j|k} \cdot p_{k|l} = p_{j|l}
  \label{eq:arbitrage_freeness}
\end{align}
to be satisfied for the exchange rates between all tokens $ \tau_j, \tau_k, \tau_l $.

The concept of frequent batch auctions aiming at reducing arbitrage and improving liquidity has
been investigated extensively in \cite{BUDISH-ET-AL_2015:HFT}.
Moreover, the advantages of uniform-price clearing have been discussed in 
\cite{ENGELBRECHT-KAHN_1998:multi-unit-auctions}.
In this document, we want to describe the problem of determining uniform clearing prices for all
pairs of tokens involved in a multi-token batch auction process, and present a mixed-integer
programming (MIP) solution approach.


\clearpage
\section{Problem statement}
\label{sec:problem}

In this section, we want to give a high-level description of the problem that we are investigating,
thereby introducing some general notation and giving an overview of the constraints and properties
that we will focus on.

\vspace{-.3cm}
\paragraph{Data}

Let $ \tokens := \{ \tau_1 \ldots \tau_n \} $ denote the set of the $ n $ tokens that we want to
consider.
Additionally, we introduce an artificial token~$ \tau_0 $ that shall be referred to as 
\emph{reference token}, which will become important in our modelling approaches later on in 
\secref{sec:models}.
For convenience of notation, we use $ \mathcal{I}^t := \{ 1 \ldots n \} $ to denote the indices
of our token set.

Pairwise exchange rates between two tokens $ \tau_j $ and $ \tau_k $ will be denoted by
$ p_{j|k} $, meaning the price of one unit of $ \tau_j $ measured in units of $ \tau_k $.
As an example, if $ p_{j|k} = 10 $, one would need to pay an amount of $ 10 $ units of $ \tau_k $
in order to purchase one unit of $ \tau_j $.

Let there be a set $ \orders = \{ \omega_1 \ldots \omega_N \} $ of $ N $ \emph{limit sell orders}
in the batch to be processed and let $ \iorders := \{ 1 \ldots N \} $ denote its set of indices.
Every order is specified as a tuple $ \omega = (j,k,\overline{y},\pi) $ whose semantic meaning is
\vspace{-.6cm}
\begin{center}
  \emph{
    "Sell (at most) $ \overline{y} $ units of token $ \tau_j $ for token $ \tau_k $
    if the exchange rate $ p_{j|k} $ is at least $ \pi $".
  }
\end{center}
\vspace{-.5cm}
More precisely, we define and understand the elements of every such tuple as follows:
\begin{align*}
  j &\in \itokens &&
    \ldots \quad \tau_j \> \text{is the token to be sold}\\
  k &\in \itokens &&
    \ldots \quad \tau_k \> \text{is the token to be bought}\\
  \overline{y} &\in \mathbb{R}_{\ge 0} &&
    \ldots \quad \text{maximum amount of} \> \tau_j \> \text{to be sold}\\
  \pi &> 0 &&
    \ldots \quad \text{limit price for order execution, \ie} \> p_{j|k} \ge \pi
\end{align*}

Please note that, theoretically, limit buy orders could be expressed in a similar way as
a tuple~$ (j,k,\overline{x},\pi) $ that reads
\vspace{-.6cm}
\begin{center}
  \emph{
    "Buy (at most) $ \overline{x} $ units of token $ \tau_j $ for token $ \tau_k $
    if the exchange rate $ p_{j|k} $ is at most $ \pi $".
  }
\end{center}
\vspace{-.5cm}
The difference between buy and sell orders is the following:
\begin{itemize}
  \item In a buy order, a fixed (maximum) buy volume $ \overline{x} $ is set, so the trader
  indicates a preference to buy $ \overline{x} $ units of token $ \tau_j $.
  The amount of units of token $ \tau_k $ to be sold is flexible, as long as the limit price is
  respected (the smaller, the better).
  \item In a sell order, a fixed (maximum) sell volume $ \overline{y} $ is set, so the trader
  indicates a preference to sell $ \overline{y} $ units of token $ \tau_k $.
  The amount of units of token $ \tau_j $ to be bought is flexible, as long as the limit price
  is respected (the higher, the better).
\end{itemize}
\vspace{.3cm}

However, for notational simplicity, we will restrict ourselves to only considering sell orders in
this paper.
In fact, assuming that the trader has constant utility for an arbitrary number of buy-tokens,
the following argument can be used to convert limit buy orders to sell orders:
Consider a buy order $ (j,k,\overline{x},\pi) $, which reveals that the trader would be ready to
sell at most $ \pi \cdot \overline{x} $ tokens $ \tau_k $ in exchange for tokens $ \tau_j $.
Then, the trader would not object to receiving more than $ \overline{x} $ tokens $ \tau_j $ for a
maximum of $ \pi \cdot \overline{x} $ tokens $ \tau_k $, \ie if the exchange rate $ p_{j|k} $ is
lower than $ \pi $.
Hence, the trader would only benefit from submitting a sell order
$ (k,j,\pi \cdot \overline{x},\frac{1}{\pi}) $.

\paragraph{Objectives}

Having collected a batch of buy and sell orders for our set of tokens, we ultimately want to
compute exchange rates for all token pairs.
Therefore, the following optimization criteria could be used:
\begin{itemize}
  \item maximize the amount of trade that is enabled (\wrt some reference token)
  \item maximize \emph{trader welfare}, \eg defined as difference of paid price vs. limit price
\end{itemize}


\paragraph{Constraints}

The solution that we are aiming at needs to satisfy several requirements that can be stated on a
high level as follows:
\begin{itemize}
  \item \emph{(limit price)}:\\
  for all orders
  $ \omega = (j,k,\overline{y},\pi) \in \orders $:
  the order can only be executed (fully or fractionally) if the exchange rate satisfies the
  limit price, \ie $ p_{j|k} \ge \pi $.
  \item \emph{(token balance)}:\\
  for every token $ \tau \in \tokens $: the amount of tokens $ \tau $ that were bought must
  equal the amount of tokens $ \tau $ that were sold across all orders.
  \item \emph{(price coherence)}:\\
  for all token pairs $ (\tau_j,\tau_k) $: $ p_{j|k} \cdot p_{k|j} = 1 $.
  \item \emph{(arbitrage freeness)}:\\
  for all token triples $ (\tau_j,\tau_k,\tau_l) $: $ p_{j|k} \cdot p_{k|l} = p_{j|l} $.
\end{itemize}

\newpage
\begin{lemma}
  (arbitrage freeness) $ \Rightarrow $ (price coherence).
\end{lemma}
\vspace{-.8cm}
\begin{proof}
  Consider three tokens $ \{\tau_j,\tau_k,\tau_l\} \subset \tokens $.
  We apply the arbitrage-freeness condition twice:
  \begin{align*}
    \text{(i)}  \>\> p_{j|k} \cdot p_{k|l} &= p_{j|l} \\
    \text{(ii)} \>\> p_{j|l} \cdot p_{l|k} &= p_{j|k}
  \end{align*}
  Inserting (i) into (ii) and assuming prices to be strictly positive yields
  \begin{align*}
    p_{j|k} \cdot p_{k|l} \cdot p_{l|k} = p_{j|k}
    \qquad \Leftrightarrow \qquad
    p_{k|l} \cdot p_{l|k} = 1
  \end{align*}
\end{proof}
\vspace{-.4cm}

Notice that the above constraints also imply $ p_{j|j} = 1 $ for every
token~$ \tau_j \in \tokens $.

\begin{comment}
\paragraph{Properties}

Here is a list of research questions that we would like to answer.

\begin{itemize}
  \item In an optimal solution, is it guaranteed that orders can always be fully executed if their
  limit prices are strictly higher (buy order) or lower (sell order) than the exchange rate between
  the respective token pair?
  If true, we would only need to resort to partially executing orders if the execution price is
  equal to the limit price.
  \item What is the impact of optimizing the trading volume vs. the traders' welfare?
\end{itemize}
\end{comment}

\paragraph{Example}

A typical instance of our batch auction problem could look like shown in 
\figref{fig:order-token-graph}.
It is assumed that some token pairs will encounter high trading demand whereas other will only
rarely be traded on.

\begin{figure}[h!]
  \centering
  \includegraphics[width=.75\textwidth]{figures/token_order_graph.png}
  \caption{Token-order-graph representing a multi-token batch auction instance. Nodes correspond
  to tokens (with their size indicating the trading demand), the thickness of an edge represents 
  the number of orders placed on the respective token pair.}
  \label{fig:order-token-graph}
\end{figure}


\clearpage
\section{Models and Formulations}
\label{sec:models}

In this section, we want to present and discuss several solution approaches for our batch auction
problem in terms of mathematical optimization formulations.

\vspace{-.2cm}
\paragraph{Data}

At first, we will express all information given in the orders in terms of data matrices and
vectors, aiming at being able to write down a complete optimization model.
Recall that every limit sell order $ \omega \in \orders $ is defined by a tuple
$ (j,k,\overline{y},\pi) $ specifying the sell- and buy-token, the maximum amount of
tokens to be sold, as well as the limit price.

We introduce two data matrices
\begin{align*}
  \mathbf{T}^b &\in \{0,1\}^{N \times n} && \text{with} & \mathbf{T}^b \ni t^b_{i,j} = 1
  &\Leftrightarrow
  \text{token} \; \tau_j \; \text{to be bought in order} \; \omega_i \\
  \mathbf{T}^s &\in \{0,1\}^{N \times n} && \text{with} & \mathbf{T}^s \ni t^s_{i,j} = 1
  &\Leftrightarrow
  \text{token} \; \tau_j \; \text{to be sold in order} \; \omega_i
\end{align*}
As for now, we are only considering orders of one token type against one other, so there must be
exactly one entry equal to $ 1 $ per row (order) in both $ \mathbf{T}^b $ and $ \mathbf{T}^s $.

Let $ (\overline{y}_i) =: \overline{\mathbf{y}} \in \mathbb{R}^N_{\ge 0} $
contain the maximum amounts of tokens to be sold in every order.

Finally, the limit prices of all orders shall be stored as vector
$ (\pi_i) =: \bm{\pi} \in \mathbb{R}^N_{\ge 0} $, where $ \pi_i \in \bm{\pi} $ refers to the
exchange rate between the respective buy and sell tokens at which order $ \omega_i $ may be
executed (according to the definition in \subsecref{sec:problem}).

\vspace{-.2cm}
\paragraph{Variables}

Primarily, we want to determine exchange rates between all token pairs.
However, if we directly considered those exchange rates being variables, modelling
arbitrage-freeness constraints of type \eqref{eq:arbitrage_freeness} automatically leads to many
multiplications being required.
This may result in unnecessary limitations to the problem size that is tractable as well as
numerical instability.
In order to circumvent this issue, we can instead represent all token prices only with respect to
the single (artificial) reference token $ \tau_0 $.
Therefore, let $ p_j := p_{j|0} $ denote the price of token $ \tau_j $ expressed in units of
$ \tau_0 $ (hence, $ p_0 = 1 $).
Applying the arbitrage-freeness and price-coherence conditions directly, we can express the
exchange rate between two tokens $ \tau_j $ and $ \tau_k $ as
\begin{align}
  p_{j|k} = p_{j|0} \cdot p_{0|k} = \frac{p_{j|0}}{p_{k|0}} = \frac{p_j}{p_k}.
\end{align}
Let $ \mathbf{p} \in \mathbb{R}^n_{> 0} $ be a vector containing all prices $ p_j $.

We now have some freedom to decide what precisely the artificial reference token should represent.
For example, we could select one particular $ \tau_j \in \tokens $ to be the \emph{numeraire}, \ie
\begin{subequations}
\begin{align}
  p_0 &= p_j.
  \label{eq:refToken_1}
\end{align}
Then, all trading volume would be computed \wrt $ \tau_j $ (which we will explain later in the
model formulation sections), making this the principal token in the batch auction.
Alternatively and more generally, we could also identify $ \tau_0 $ with a weighted sum of all
participating tokens in $ \tokens $, \ie
\begin{align}
  p_0 &= \sum\limits_{j \in \itokens} \gamma_j \cdot p_j,
  \label{eq:refToken_2}
\end{align}
\end{subequations}
with weights $ \gamma_j > 0 $.
This way, it is possible to give similar importance to all tokens.
In the following, we will use \eqref{eq:refToken_2} together with weights
$ \gamma_j = 1 / (n \cdot p_j^\mathrm{old}) $, where $ p_j^\mathrm{old} $ denotes the price of
token $ \tau_j $ found in the previous batch auction iteration. 

\todo[inline]{Implications of unavailable $ p_j^\mathrm{old} $?!}

\vspace{.2cm}
\begin{observation}
The choice of representation of the reference token has an influence on the solution.
This can be seen by considering a single token pair $ (\tau_j,\tau_k) $ with only two buy orders
$ \omega_1 = (j,k,1.0,+\infty,2.0) $ and $ \omega_2 = (k,j,1.5,+\infty,1.0) $.
Both orders can be matched if $ p_{j|k} \in [1,2] $.
However, if we choose token $ \tau_j $ to be the reference token, a maximum of $ 1.0 \, \tau_j $
can be transacted for prices $ p_{j|k} \in [1,1.5] $, whereas the maximum trading volume of
$ 1.5 \, \tau_k $ can be achieved when $ p_{j|k} \in [1.5,2] $.
\end{observation}

Additionally, we want to bound the deviation of the new exchange rates $ p_{j|k} $ from the
previously computed exchange rates $ p_{j|k}^\mathrm{old} $.
Therefore, let $ p^\mathrm{old}_j $ denote the price of token~$ \tau_j $ found in the previous
batch auction iteration.
Using a maximum fluctuation parameter $ \delta > 0 $, we impose the conditions
\begin{align}
  p_{j|k} \in
  \left[
    \left(\frac{1}{1+\delta}\right) p^\mathrm{old}_{j|k},
    (1+\delta) \, p^\mathrm{old}_{j|k}
  \right]
  \quad &\Leftrightarrow \quad
  \frac{p_j}{p_k} \in
  \left[
    \left(\frac{1}{1+\delta}\right) \frac{p^\mathrm{old}_j}{p^\mathrm{old}_k},
    (1+\delta) \, \frac{p^\mathrm{old}_j}{p^\mathrm{old}_k}
  \right]\notag\\[2mm]
  \quad &\Leftrightarrow \quad
  \begin{cases}
    p_j \ge \left(\frac{1}{1+\delta}\right) \frac{p^\mathrm{old}_j}{p^\mathrm{old}_k} \, p_k
    \\[2mm]
    p_j \le \left(1+\delta\right) \frac{p^\mathrm{old}_j}{p^\mathrm{old}_k} \, p_k
  \end{cases}.
  \label{eq:bounds_xrates}
\end{align}

As an example, $ \delta = 1 $ would set the bounds to half/twice the previous exchange rates.
Note that, if no previous price exists for some token $ \tau_j $, the exchange rate bounds for
token pairs involving $ \tau_j $ could be determined on the basis of the limit prices given in
the respective orders, or simply be set to $ [0,\infty] $.
In theory, the model permits a different fluctuation parameter on every token pair, which allows to
capture real-world expections, \eg, related to the liquidity that is available on each token pair. 

Moreover, it is helpful to incorporate some explicit lower and upper bound for the price of every
token~$ \tau_j $, so let us require $ p_j \in [\underline{p}_j,\overline{p}_j] $.

\begin{lemma}
  For the choice of weights $ \gamma_j = 1 / (n \cdot p_j^\mathrm{old}) $ in \eqref{eq:refToken_2}
  and a given maximum fluctuation parameter $ \delta $, we can impose bounds
  \begin{align}
    p_j \in \left[ \left(\frac{1}{1+\delta}\right) \, p^\mathrm{old}_j, (1+\delta) \,
  p^
  \mathrm{old}_j \right] \forall \, j \in \itokens.
  \end{align}
\end{lemma}
\vspace{-.5cm}
\begin{proof}
  We will prove that the upper bound holds.
  Proving the lower bound works analogous.
  Assume $ p_j > (1+\delta) \, p_j^\mathrm{old} $.
  Then, \eqref{eq:bounds_xrates} yields
  \begin{align*}
    (1+\delta) \, \frac{p^\mathrm{old}_j}{p^\mathrm{old}_k} \, p_k > (1+\delta) \, p_j^\mathrm{old}
    \qquad \Leftrightarrow \qquad p_k > p_k^\mathrm{old}
    \qquad \forall k \neq j.
  \end{align*}
  Inserting into \eqref{eq:refToken_2} leads to a contradiction:
  \begin{align*}
    p_0 = 1
    &= \frac{1}{n \cdot p_j^\mathrm{old}} \, p_j + \sum\limits_{j \neq k \in \itokens}
      \frac{1}{n \cdot p_k^\mathrm{old}} \cdot p_k
    \, > \, \frac{1+\delta}{n} + \sum\limits_{j \neq k \in \itokens} \frac{1}{n} > 1.
  \end{align*}
\end{proof}
\vspace{-.4cm}

All price bounds shall be stored in vectors $ \underline{\mathbf{p}} $ and $ \overline{\mathbf{p}}
$, respectively.

In addition to computing optimal token prices $ \mathbf{p} $, we also want to determine the status
of execution for every order, \ie the amount of tokens that were bought and sold.
Therefore, the number of tokens bought in an order $ \omega_i $ shall be denoted by $ x_i $, with
$ (x_i) =: \mathbf{x} \in \mathbb{R}^N_{\ge 0} $.
Conversely, $ (y_i) =: \mathbf{y} \in \mathbb{R}^N_{\ge 0} $ shall represent the amounts of tokens
sold.

We need to distinguish two different behaviours for every order: Either the exchange rate
on the respective token pair satisfies its limit price (and thus the order may be executed), or it
does not (thus the order needs to remain untouched).
Optionally, we could incorporate a minimum fraction of execution, denoted by a parameter
$ r^\Min \in [0,1] $, for the case that an order may be executed.
This parameter can either be set globally for all orders, or for every order individually.

In general, for an order given as $ \omega = (j,k,\overline{y},\pi) $, this yields
the following two sets of constraints:
\begin{align}
  \mathfrak{C}^1 := \left\{
  \begin{array}{rll}
    y &\in & [\, r^\Min \, \overline{y}, \, \overline{y}\,] \\
    y \cdot p_j &= & x \cdot p_k \\[1mm]
    \frac{p_j}{p_k} &\ge & \pi
  \end{array}
  \right\}
  \quad
  \text{and}
  \quad
  \mathfrak{C}^0 := \left\{
  \begin{array}{rll}
    x &= & 0 \\
    y &= & 0 \\[1mm]
    \frac{p_j}{p_k} &< & \pi
  \end{array}
  \right\}
  \label{eq:order_model_generic}
\end{align}

\paragraph{Objective}

Our primary objective shall be to determine token prices/exchange rates such that the total
feasible \emph{trading volume} is maximized.
Thereby, trading volume refers to the sum of all tokens traded across all orders, weighted by their
respective price, \ie it measures the value of all transactions in terms of units of the reference
token $ \tau_0 $.
Thus, for every order $ \omega = (j,k,\overline{y},\pi) $, we introduce an additional
variable $ v \ge 0 $, for which we require
\begin{align}
  v = y \cdot p_j \qquad \text{and} \qquad v = x \cdot p_k
  \label{eq:trading_volume}
\end{align}
The trading volumes of all orders shall be stored in a vector
$ \mathbf{v} \in \mathbb{R}^N_{\ge 0} $.
It is then our objective to maximize $ \sum_{i \in \iorders} v_i $.

Alternatively, we want to consider optimizing the total \emph{trading surplus}
(or \emph{traders' welfare}).
If some sell order $ \omega = (j,k,\overline{y},\pi) $ is executed, \ie a certain amount~$ y $
of token~$ \tau_j $ sold, the trading surplus $ w $ measures the value of the difference between
the amount~$ x $ of tokens $ \tau_k $ that is purchased and the minimum amount~$ y \cdot \pi $ that
the trader would have accepted:
\begin{align}
  w &= ( x - y \> \pi ) \> p_k \\
    &= x \> p_k - y \> \pi \> p_k \\
    &= v -  y \cdot \pi \cdot p_k
  \label{eq:trading_surplus}
\end{align}


\todo[inline]{Write about traders' surplus!}


\newpage
\subsection{Nonlinear programming model}
\label{subsec:NLPmodel}

When looking at the sets of constraints \eqref{eq:order_model_generic}, the most intuitive model
seems to be a nonlinear program.
As we will see, it is possible to avoid binary variables.

\begin{subequations}
\begin{align}
  \text{maximize} \quad & \sum\limits_{i \in \iorders} v_i
  \label{eq:nlp_objective}
  \\[2mm]
  \text{subject to} \quad
  \sum\limits_{i \in \iorders} t^b_{i,j} \, x_i
  &= \sum\limits_{i \in \iorders} t^s_{i,j} \, y_i
  && \forall \> j \in \itokens
  \label{eq:nlp_tokenbalance}
  \\[2mm]
  v_i
  &= x_i \sum\limits_{j \in \itokens} t^b_{i,j} \, p_j
  && \forall \> i \in \iorders
  \label{eq:nlp_buyvolume}
  \\[1mm]
  v_i
  &= y_i \sum\limits_{j \in \itokens} t^s_{i,j} \, p_j
  && \forall \> i \in \iorders
  \label{eq:nlp_sellvolume}
  \\[2mm]
  y_i &\le \overline{y}_i
  && \forall \> i \in \iorders
  \label{eq:nlp_tokenamount_1}
  \\[1mm]
  x_i &\ge y_i \, \pi_i
  && \forall \> i \in \iorders
  \label{eq:nlp_tokenamount_2}
  \\[2mm]
  n
  &= \sum\limits_{j \in \itokens} \frac{1}{p^\mathrm{old}_j} \cdot p_j,
  \label{eq:nlp_reftoken}
  \\[1mm]
  p_j
  &\le \left(1+\delta\right) \frac{p^\mathrm{old}_j}{p^\mathrm{old}_k} \, p_k
  && \forall j,k \in \itokens \times \itokens
  \label{eq:nlp_maxfluct}
  \\[2mm]
  x_i, y_i, v_i &\in \mathbb{R}_{\ge 0}
  && \forall \> i \in \iorders
  \\[1mm]
  p_j
  &\in \left[ \left(\frac{1}{1+\delta}\right) \> p^\mathrm{old}_j, (1+\delta) \> p^\mathrm{old}_j
  \right]
  && \forall \> j \in \itokens
\end{align}
\label{eq:nlp}
\end{subequations}

The objective function \eqref{eq:nlp_objective} maximizes the total volume in terms of units of
the reference token $ \tau_0 $ that is processed with all orders.

Constraint \eqref{eq:nlp_tokenbalance} ensures that the total numbers of tokens bought and sold are
equal for every token across all orders.
The summations in this constraint are only responsible for selecting the correct tokens that are
traded in the orders.

The constraints~\eqref{eq:nlp_buyvolume} and \eqref{eq:nlp_sellvolume} compute the buy and sell
trade volume for every order \wrt the reference token, and make sure these two are equal.
This guarantees that the token prices are chosen such that they are consistent with the traded
amounts of tokens.
If the traded token amounts $ x_i $ and $ y_i $ are zero for some order $ \omega_i $, \ie
$ \omega_i $ is not executed at all, the corresponding trade volume $ v_i $ will be zero as well.
However, this comes at the price of introducing nonlinearity (and even nonconvexity) into the
model.

The maximum token amount to be sold as specified in every limit order is incorporated into the
model via constraint~\eqref{eq:nlp_tokenamount_1}.
Constraint~\eqref{eq:nlp_tokenamount_2} ensures that the limit price is satisfied, if the order is
to be executed, or that both $ x_i $ and $ y_i $ are set to zero otherwise.
Altogether, the constraints~\eqref{eq:nlp_buyvolume}--\eqref{eq:nlp_tokenamount_2} capture both
cases of \eqref{eq:order_model_generic} simultaneously.

Finally, as described earlier, the constraints \eqref{eq:nlp_reftoken} and \eqref{eq:nlp_maxfluct}
specify the representation of the reference token and enforce a maximum fluctuation of exchange
rates on all token pairs.

This model allows for orders to be left untouched even if the computed token prices satisfy the
given limit price, so there is no way to express a value other than $ r^\Min = 0 $ for the
minimum order execution parameter.
While this may a desirable property of the model, we believe that this can only be amended with
the introduction of binary variables that indicate whether prices allow for an order to be
executed, or not.


\newpage
\subsection{Mixed-integer linear programming model I}
\label{subsec:MIP1}

Since nonlinearity and nonconvexity usually pose strong restrictions on the tractable model size,
we want to proceed with proposing a mixed-integer linear programming (MIP) formulation as an
alternative to the NLP model presented above.
Thereby, the challenge is to find an equivalent linear formulation for 
\eqref{eq:order_model_generic}.

The key idea is to avoid explicitely computing the values $ x $ and $ y $ for every order
$ \omega = (j,k,\overline{y},\pi) $, but only working with the trading volume $ v $ as
defined in \eqref{eq:trading_volume} instead.
With uniform clearing prices, $ x $ and $ y $ can be computed unambiguously from the value of $ v $
later on.
The order constraints \eqref{eq:order_model_generic} can be expressed as follows:
\begin{align}
  \tilde{\mathfrak{C}}^1 := \left\{
  \begin{array}{rlll}
    v &\in & [\>r^\Min \> \overline{y} \> p_j, \>\overline{y} \> p_j \>] \\[1mm]
    \frac{p_j}{p_k} &\ge & \pi
  \end{array}
  \right\}
  \quad
  \text{and}
  \quad
  \tilde{\mathfrak{C}}^0 := \left\{
  \begin{array}{rll}
    v &= & 0 \\[1mm]
    \frac{p_j}{p_k} &< & \pi
  \end{array}
  \right\}
  \label{eq:order_model_mip1}
\end{align}

In order to reformulate \eqref{eq:order_model_mip1} in terms of a mixed-integer linear program,
we first introduce a binary variable $ z \in \{0,1\} $ for every order and associate its states to
the constraint sets as $ \{z = 1\} \Leftrightarrow \tilde{\mathfrak{C}}^1 $ and
$ \{z = 0\} \Leftrightarrow \tilde{\mathfrak{C}}^0 $.
For modelling these dependencies, there exist two major strategies that we will apply in the
following:
the \emph{big-M} approach as, \eg mentioned in \cite{BONAMI-ET-AL_2015:indicator-constraints},
as well as \emph{disjunctive programming}, introduced by \textsc{Balas} \cite{BALAS_1979:DP}.

\paragraph{Big-M reformulation}

In the big-M approach, the constraints for both $ \tilde{\mathfrak{C}}^0 $ and
$ \tilde{\mathfrak{C}}^1 $ are modified so that they are equivalent to the original ones if the
binary variable takes the respective value, and are rendered redundant by large-enough constants in
the opposite case.
As for our constraint systems, this translates into:
\begin{subequations}
\begin{align}
  p_j &\ge \pi \, p_k + (1-z) (\underline{p}_j - \pi \overline{p}_k) \\
  p_j &\le (\pi-\varepsilon) \, p_k
    + z \, (\overline{p}_j - (\pi-\varepsilon) \, \underline{p}_k) \\[1mm]
  v &\le \overline{y} \, p_j \\
  v &\le \overline{y} \, \overline{p}_j \, z \\
  v &\ge r^\Min \, \overline{y} \, (p_j - (1-z) \, \overline{p}_j)
\end{align}
\label{eq:order_model_mip1_bigM}
\end{subequations}

It can easily be verified that substituting $ z=1 $ and $ z=0 $ yields the desired constraints
\eqref{eq:order_model_mip1}.
Notice that the strict inequality $ \frac{p_j}{p_k} < \pi $ in $ \tilde{\mathfrak{C}}^0 $ is
approximated by an inequality $ \frac{p_j}{p_k} \le \pi - \varepsilon $, with some very small
$ \varepsilon > 0 $.

\paragraph{Disjunctive programming reformulation}

The advantage of the big-M reformulation is its simplicity and compactness.
However, its relaxation is not as tight as it can be, \ie it does not describe the convex hull of
the feasible regions of $ \tilde{\mathfrak{C}}^0 $ and $ \tilde{\mathfrak{C}}^1 $.
This property can be secured in the disjunctive programming approach through the addition of
additional auxiliary variables.

For every order $ \omega = (j,k,\overline{y},\pi) $, we introduce two pairs of auxiliary
non-negative price variables:
$ p^{s,0}, p^{s,1} $ -- referring to the price $ p_j $ of the sell-token, as well as
$ p^{b,0}, p^{b,1} $ -- referring to the price $ p_k $ of the buy-token.
Then, a disjunctive programming formulation can be given as follows:
\begin{subequations}
\begin{align}
  (1-z) \, \underline{p}_j &\le p^{s,0} \le (1-z) \, \overline{p}_j
    \label{eq:mip1_dp_sellprice_0}\\
  (1-z) \, \underline{p}_k &\le p^{b,0} \le (1-z) \, \overline{p}_k
    \label{eq:mip1_dp_buyprice_0}\\
  z \, \underline{p}_j &\le p^{s,1} \le z \, \overline{p}_j
    \label{eq:mip1_dp_sellprice_1}\\[2mm]
  z \, \underline{p}_k &\le p^{b,1} \le z \, \overline{p}_k
    \label{eq:mip1_dp_buyprice_1}\\
  p_j &= p^{s,0} + p^{s,1}
    \label{eq:mip1_dp_sellprice_aggr}\\
  p_k &= p^{b,0} + p^{b,1}
    \label{eq:mip1_dp_buyprice_aggr}\\[2mm]
  p^{s,1} &\ge \pi \, p^{b,1}
    \label{eq:mip1_dp_xrate_1}\\
  p^{s,0} &\le (\pi-\varepsilon) \, p^{b,0}
    \label{eq:mip1_dp_xrate_0}\\[2mm]
  v &\le \overline{y} \, p^{s,1}
    \label{eq:mip1_dp_volume_sell_ub}\\
  v &\ge r^\Min \, \overline{y} \, p^{s,1}
    \label{eq:mip1_dp_volume_sell_lb}
\end{align}
\label{eq:order_model_mip1_DP}
\end{subequations}

The general idea is that both $ p^{s,1} $ and $ p^{b,1} $ shall take the true value of $ p_j $ and
$ p_k $ within the respective bounds if $ z = 1 $ (\ie the order can be executed), and be set to
zero otherwise; and vice-versa for $ p^{s,0} $ and $ p^{b,0} $.
This is modelled through constraints \eqref{eq:mip1_dp_buyprice_0}--\eqref{eq:mip1_dp_sellprice_1}.
The aggregation of the auxiliary price variables to the actual token prices is expressed in
constraints \eqref{eq:mip1_dp_buyprice_aggr} and \eqref{eq:mip1_dp_sellprice_aggr}.
All the other constraints \eqref{eq:mip1_dp_xrate_1}--\eqref{eq:mip1_dp_volume_sell_lb} represent
the original model constraints from \eqref{eq:order_model_mip1}, now expressed in terms of the
auxiliary variables.

\paragraph{Model}

Using either of the two reformulations of \eqref{eq:order_model_mip1} for all orders as a
substitution for \eqref{eq:mip1_orderdisj}, the full MIP model can be stated as:
\begin{subequations}
\begin{align}
  \text{maximize} \quad & \sum\limits_{i \in \iorders} v_i
  \label{eq:mip1_objective}
  \\[2mm]
  \text{subject to} \quad
  \sum\limits_{i \in \iorders} t^b_{i,j} \, v_i
  &= \sum\limits_{i \in \iorders} t^s_{i,j} \, v_i
  && \forall \> j \in \itokens
  \label{eq:mip1_tokenbalance}
  \\[4mm]
  \tilde{\mathfrak{C}}^1_i &\lor \tilde{\mathfrak{C}}^0_i
  && \forall \> i \in \iorders
  \label{eq:mip1_orderdisj} 
  \\[2mm]
  n
  &= \sum\limits_{j \in \itokens} \frac{1}{p^\mathrm{old}_j} \cdot p_j,
  \label{eq:mip1_reftoken}
  \\[1mm]
  p_j
  &\le \left(1+\delta\right) \frac{p^\mathrm{old}_j}{p^\mathrm{old}_k} \, p_k
  && \forall j,k \in \itokens \times \itokens
  \label{eq:mip1_maxfluct}
  \\[2mm]
  v_i
  &\in \mathbb{R}_{\ge 0}
  && \forall \> i \in \iorders
  \\[1mm]
  p_j
  &\in \left[ \frac{1} {1+\delta} \> p^\mathrm{old}_j, (1+\delta) \> p^\mathrm{old}_j \right]
  && \forall \> j \in \itokens
\end{align}
\label{eq:mip1}
\end{subequations}

\vspace{-.5cm}
\paragraph{Additional inequalities}

The model does not take into account that there exist dependencies between orders on the same token
pair, that can heuristically be described as follows:
Whenever an order with a certain limit price $ \pi^* $ is executed (fully or partially) at some
determined market price, all orders offering an even better limit price must also be executed.
Conversely, if some order can not be executed, all orders with worse limit prices may not be
executed as well.
This idea induces a natural ordering of the orders that we are now going to formalize:
let the set of (undirected) token index pairs be denoted by
$ \itokenpairs := \{(j,k) \in \itokens \times \itokens, j < k\} $, with $ (j,k) \in \itokenpairs $
representing the pair of tokens $ \tau_j $ and $ \tau_k $.

For every token pair $ (j,k) \in \itokenpairs $, we collect all orders for which $ \tau_j $ is the
token to be bought and $ \tau_k $ is the token to be sold, \ie all
$ \omega = (j, k,\, \cdot \,,\, \cdot \,,\, \cdot) \in \orders $,
and sort them in an increasing order by their limit prices.
Assuming that there are $ m $ such orders for token pair $ (j,k) $, we get
$ \pi^{(1)}_{j,k} < \pi^{(2)}_{j,k} < \ldots < \pi^{(m)}_{j,k} $.
We then pick the binary variables $ z_i $ belonging to the orders under consideration, and permute
them into the same order, \ie $ (z^{(0)}, z^{(1)}, \ldots, z^{(m)}) $.
The idea described above consequently translates into precedence constraints of the form
\begin{align}
  z^{(l)} \le z^{(l+1)} \qquad \forall \, l = 1 \ldots m\!-\!1.
  \label{eq:mip1_order_precedence}
\end{align}
We repeat the same procedure for all orders
$ \omega = (k, j,\, \cdot \,,\, \cdot \,,\, \cdot) \in \orders $,
\ie for opposite roles of the tokens involved.
In our computational experiments, these constraints proven to be very beneficial for the solving
performance.

Moreover, we can also find inequalities for subsets of orders that are mutually exclusive, \ie not
all orders in such a subset can be executed at the same time.
In particular, on a token pair $ (j,k) \in \itokenpairs $, if there are two orders
$ \omega^{(1)} = (j,k,\cdot,\cdot,\pi^{(1)}) $ and $ \omega^{(2)} = (k,j,\cdot,\cdot,\pi^{(2)}) $,
where $ \pi^{(1)} \cdot \pi^{(2)} < 1 $, we can conclude that at most one of them may be active in
order to maintain arbitrage-freeness \eqref{eq:arbitrage_freeness}.
This can be written as inequality 
\begin{subequations}
\begin{align}
  z^{(1)} + z^{(2)} \le 1.
  \label{eq:mip1_order_exclusion}
\end{align}
This type of inequality can of course also be generalized to chains of orders along cycles of
tokens.
Let $ (\tau_{j_1}, \tau_{j_2}, \ldots, \tau_{j_m}, \tau_{j_1}) $ be such a token cycle of length
$ m $.
Then, for a set of orders
$ \{
\omega^{(1)} = (j_1,j_2,\cdot,\cdot,\pi^{(1)}), \>
\omega^{(2)} = (j_2,j_3,\cdot,\cdot,\pi^{(2)}), \>
\ldots, \>
\omega^{(m)} = (j_m,j_1,\cdot,\cdot,\pi^{(m)})
\} $
with $ \prod_{i=1}^m \pi^{(i)} < 1 $, the following needs to hold:
\begin{align}
  \sum\limits_{i=1}^m z^{(i)} \le m-1.
  \label{eq:mip1_order_exclusion_general}
\end{align}
\end{subequations}

In both cases, there are many possible choices of subsets of orders that are mutually exclusive.
This holds true in particular for the generalized constraint variant
\eqref{eq:mip1_order_exclusion_general} the longer the token cycles become.
Hence, for instances with a large number of orders, it will be impractical to include all possible
inequalities, so some care should be taken on selecting the most impactful ones.
So far, we have done experiments with cycle lengths $ m \in \{2,3\} $, in which the mutual
exclusion constraints have shown to have a significant positive impact on the solving process.

\todo[inline]{Which inequalities to select!?}


\newpage
\subsection{Mixed-integer linear programming model II}
\label{subsec:MIP2}

In the previous MIP model \eqref{eq:mip1}, we have modelled the constraints of every order
separately, \ie we have used one binary disjunctive formulation per order that controls its
behavior in case it may or may not be executed.
On top of that, we have used the equations \eqref{eq:mip1_order_precedence} to indicate the
dependencies between orders on the same token pair.
However, we can also encode these dependencies deeper into the model by considering order volumes
within certain price ranges on a token pair in a somewhat aggregated fashion.
This approach gives rise to an alternative MIP formulation that we will present in the following.

As before, let $ \itokenpairs := \{(j,k) \in \itokens \times \itokens, j < k\} $ denote the index
set of (undirected) pairs of tokens.
We want to aggregate orders on every token pair, so we collect all buy and sell orders on
$ (j,k) $, \ie all $ \omega = (j, k,\, \cdot \,,\, \cdot \,) \in \orders $ and
$ \omega = (k, j,\, \cdot \,,\,\cdot \,) \in \orders $, and sort them in an increasing order of
their limit prices.
Assuming that there are $ m $ orders for token pair $ (j,k) $, we get
\begin{align}
  \underline{p}_{j|k} =:
    \pi^{(0)}_{j,k} < \pi^{(1)}_{j,k} < \pi^{(2)}_{j,k} <
    \ldots < \pi^{(m)}_{j,k} < \pi^{(m+1)}_{j,k}
  := \overline{p}_{j|k},
  \label{eq:mip2_limit_price_ordering}
\end{align}
where $ \underline{p}_{j|k} $ and $ \overline{p}_{j|k} $ are explicit but somewhat arbitrary bounds
on the exchange rate (\eg half and double the previous rate).
The above ordering \eqref{eq:mip2_limit_price_ordering} defines regions
$ r_l := [\pi^{(l)},\pi^{(l+1)}] $, $ l \in \{0 \ldots m\} $, for the exchange rate $ p_{j|k} $.
Notice that, without loss of generality and for simplicity of notation, we assume the limit prices
of all orders to be pairwise different, so that the strict inequalities in 
\eqref{eq:mip2_limit_price_ordering} hold.
If some limit prices were equal, we would only end up with less exchange rate regions.
Let $ \mathcal{I}_{j,k}^r := \{0 \ldots m\} $ denote the set of all such regions for every token
pair $ (j,k) $, \ie $ l \in \mathcal{I}_{j,k}^r $ refers to the interval $ r_l $ of that token
pair.

Now, let $ \tilde{x}_{j,k,l}^{(1)} $ denote to the cumulated amount of tokens $ \tau_j $ that could
be bought across all buy orders $ \omega = (j,k,\cdot,\cdot,\cdot) \in \buyorders $ if the
exchange rate $ p_{j|k} $ were in $ r_l $.
Conversely, let $ \tilde{x}_{j,k,l}^{(2)} $ denote the cumulated number of available tokens
$ \tau_k $ in buy orders $ \omega = (k,j,\cdot,\cdot,\cdot) \in \buyorders $.
Both shall be stored in vectors $ \tilde{\mathbf{x}}^{(1)} := (\tilde{x}_{j,k,l}^{(1)}) $ and
$ \tilde{\mathbf{x}}^{(2)} := (\tilde{x}_{j,k,l})^{(2)} $.
Analogously, we aggregate available sell tokens for sell orders
$ \omega = (j,k,\cdot,\cdot,\cdot) \in \sellorders $ and
$ \omega = (k,j,\cdot,\cdot,\cdot) \in \sellorders $, and store them in
$ \tilde{\mathbf{y}}^{(1)} := (\tilde{y}_{j,k,l}^{(1)}) $
and $ \tilde{\mathbf{y}}^{(2)} := (\tilde{y}_{j,k,l}^{(2)}) $, respectively.
From here on, we are only working with this aggregated order representation.

In terms of variables, we will use the same price variables $ \mathbf{p} \in \mathbb{R}^n_{\ge 0} $
as previously.
In addition, we will use variables $ \mathbf{v}^A := (v^A_{j,k,l}) $ and
$ \mathbf{v}^B := (v^B_{j,k,l}) $ to represent trading volumes for every price interval $ r_l $ on
every token pair $ (j,k) $.
Moreover, we represent the total absolute and net trading volume on each token pair by
$(v_{j,k}^\mathrm{abs}) =: \mathbf{v}^\mathrm{abs} \in \mathbb{R}_{\ge 0}^{\mid \itokenpairs \mid}$
and
$(v_{j,k}^\mathrm{net}) =: \mathbf{v}^\mathrm{net} \in \mathbb{R}_{\ge 0}^{\mid \itokenpairs \mid}$.

\newpage
If the exchange rate on a token pair $ (j,k) $ falls into region $ r_l $, the following set of
constraints needs to hold:
\begin{align}
  \tilde{\mathfrak{C}}^{(l)}_{j,k} := \left\{
  \begin{array}{rll}
    v^A_{j,k,l}
      &\ge & r^\Min \left( \tilde{x}_{j,k,l}^{(1)} \, p_j + \tilde{y}_{j,k,l}^{(2)} \, p_k \right)
    \\[2mm]
    v^A_{j,k,l}
      &\le & \tilde{x}_{j,k,l}^{(1)} \, p_j + \tilde{y}_{j,k,l}^{(2)} \, p_k
    \\[4mm]
    v^B_{j,k,l}
      &\ge & r^\Min \left( \tilde{y}_{j,k,l}^{(1)} \, p_j + \tilde{x}_{j,k,l}^{(2)} \, p_k \right)
    \\[2mm]
    v^B_{j,k,l}
      &\le & \tilde{y}_{j,k,l}^{(1)} \, p_j + \tilde{x}_{j,k,l}^{(2)} \, p_k
    \\[4mm]
    p_j & \ge & \pi_{j,k}^{(l)} \, p_k \\[2mm]
    p_j & \le & \pi_{j,k}^{(l+1)} p_k
  \end{array}
  \right\}
  \label{eq:mip2_disj}
\end{align}

On a token pair $ (j,k) $ with $ m $ regions $ r_l $, the disjunction
$ \bigvee\limits_{l \in \{0 \ldots m\}} \tilde{\mathfrak{C}}^{(l)}_{j,k} $
needs to be satisfied.

\paragraph{Model}

Similarly as described in \subsecref{subsec:MIP1} for the first MIP model, \eqref{eq:mip2_disj} can
be reformulated using either a big-M or a disjunctive programming approach.
Without going into detail about this, the overall model reads as in \eqref{eq:mip2}.

The objective function \eqref{eq:mip2_objective} maximizes the sum of the trading volumes over all
trading pairs and is supposed to yield the same value as the objective \eqref{eq:mip1_objective} of
the previous MIP model.

The first constraint \eqref{eq:mip2_tokenbalance} secures, again, the token balance for every token
by requiring the net traded volumes to be balanced over all token pairs in which the respective
token is involved.

\newpage
\begin{subequations}
\begin{align}
  \text{maximize} \quad & \sum\limits_{(j,k) \in \itokenpairs} v_{j,k}^\mathrm{abs}
  \label{eq:mip2_objective}
  \\[2mm]
  \text{subject to} \quad
  \sum_{\substack{k \in \itokens \\ k \neq j}} v_{k,j}^\mathrm{net}
  &= \sum_{\substack{k \in \itokens \\ k \neq j}} v_{j,k}^\mathrm{net}
  && \forall \> j \in \itokens
  \label{eq:mip2_tokenbalance}
  \\[2mm]
  v_{j,k}^\mathrm{abs}
  &= \sum\limits_{l \in \tilde{\mathcal{I}}_{j,k}^r} \left( v^A_{j,k,l} + v^B_{j,k,l} \right)
  && \forall \> (j,k) \in \itokenpairs
  \label{eq:mip2_volume_aggr_abs}
  \\[2mm]
  v_{j,k}^\mathrm{net}
  &= \sum\limits_{l \in \tilde{\mathcal{I}}_{j,k}^r} \left( v^A_{j,k,l} - v^B_{j,k,l} \right)
  && \forall \> (j,k) \in \itokenpairs
  \label{eq:mip2_volume_aggr_net}
  \\[2mm]
  &\hspace{-1cm}\bigvee\limits_{l \in \{0 \ldots m\}} \tilde{\mathfrak{C}}^{(l)}_{j,k}
  && \forall \> (j,k) \in \itokenpairs
  \\[3mm]
  n
  &= \sum\limits_{j \in \itokens} \frac{1}{p^\mathrm{old}_j} \> p_j,
  \label{eq:mip2_reftoken}
  \\[2mm]
  p_j
  &\le \left(1+\delta\right) \frac{p^\mathrm{old}_j}{p^\mathrm{old}_k} \, p_k
  && \forall j,k \in \itokens \times \itokens
  \label{eq:mip2_maxfluct}
  \\[3mm]
  p_j
  &\in \left[ \frac{1}{1+\delta} \> p^\mathrm{old}_j, (1+\delta) \> p^\mathrm{old}_j \right]
  && \forall \> j \in \itokens
  \\[3mm]
  v_{j,k}^\mathrm{abs}, v_{j,k}^\mathrm{net}
  &\in \mathbb{R}_{\ge 0}
  && \forall \> (j,k) \in \itokenpairs
  \\[3mm]
  v^A_{j,k,l}, v^B_{j,k,l}
  &\in \mathbb{R}_{\ge 0}
  && \forall \> (j,k) \in \itokenpairs, l \in \tilde{\mathcal{I}}_{j,k}^r
\end{align}
\label{eq:mip2}
\end{subequations}


\newpage
\subsection{Computational comparison}
\label{subsec:computational_comparison}

In order to investigate the performance of our MIP models, we have conducted computational
experiments for different numbers of tokens ($ n \in \{5,10,20,50\} $) and orders ($ N \in 
\{100,200,500\} $).
For every combination of $ n $ and $ N $, we have generated 20 random instances, whereby the
randomness reflects our expectation of somewhat realistic situations.
In particular, we expect not all tokens to be equally important in terms of trading volume and,
hence, to have varying numbers of orders on different token pairs.
We used Gurobi 8.0.0 as MIP solver on an Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz machine with 16Gb
RAM and using 4 threads, and a timelimit set to 1800 seconds for every instance.

The value of the maximum fluctuation parameter has been set to $ \delta = 0.1 $, meaning that
prices are allowed to change by at most 10\% from the (randomly set) previous prices.
Moreover, we used $ r^\Min = 0 $, hence orders can be left untouched even if their limit price
complies with the computed exchange rate.
This guarantees that all our test instances are feasible.

The (geometric) means of the runtimes have been computed only \wrt the instances that could be
solved to optimality before the timelimit. Conversely, the average optimality gap does not take
solved instances into account.

In general, the results of our computational experiments as in \tabref{tab:results_mip1} and 
\tabref{tab:results_mip2} show that runtimes of the two MIP formulations sharply increase both with
the number of tokens and the number of orders that are being considered.
While all instances with no more than 200 orders could be solved relatively fast by all models,
instances with 500 orders are much harder to solve, with some (or even most) of the instances
running into our set timelimit.
The MIP model I \eqref{eq:mip1} generally performs better on our testsets.
Interestingly, for this model the big-M reformulation seems to be superior, whereas for the MIP
model II, running times are lower using the Disjunctive Programming reformulation.

Without further model improvements, instances with 50 tokens and 500 orders already seem to impose
a limit to the tractable problem size.
While this limit may be pushed towards somewhat bigger instances by making use of additional valid
inequalities such as \eqref{eq:mip1_order_exclusion_general}, it appears unlikely that the
tractable problem size can be increased by some orders of magnitude.
If larger problems are to be considered, we can think of the following heuristics/approximations:
\begin{itemize}
    \item Aggregate orders with similar limit prices on every asset pair
    \item Optimize over subsets of assets separately and fix prices in overall problem
\end{itemize}


\newpage
\begin{table}
  \begin{subtable}[h]{\textwidth}
    \centering
    \begin{tabular}{C{16mm}R{20mm}R{15mm}R{15mm}R{15mm}R{15mm}}
      \toprule
      && \multicolumn{4}{c}{\# assets}\\
      \cmidrule{3-6}
      \# orders &                         &    5  &    10  &     20  &    50  \\
      \midrule
      100       & $ \varnothing $ runtime &  0.15 &   0.20 &    0.24 &   0.50 \\
                & \# timeouts             &     0 &      0 &       0 &      0 \\
                & -- $ \varnothing $ gap  &     - &      - &       - &      - \\
      \midrule
      200       & $ \varnothing $ runtime &  0.42 &   1.78 &    2.26 &   6.67 \\
                & \# timeouts             &     0 &      0 &       0 &      0 \\
                & -- $ \varnothing $ gap  &     - &      - &       - &      - \\
      \midrule
      500       & $ \varnothing $ runtime &  3.46 & 158.66 &  190.70 & 896.63 \\
                & \# timeouts             &     0 &      0 &       0 &      7 \\
                & -- $ \varnothing $ gap  &     - &      - &       - & 4.23\% \\
      \bottomrule
    \end{tabular}
    \vspace{1mm}
    \caption{Big-M reformulation \eqref{eq:order_model_mip1_bigM}.}
    \label{tab:results_mip1_bigm}
  \end{subtable}
  \par\vspace{2cm}
  \begin{subtable}[h]{\textwidth}
    \centering
    \begin{tabular}{C{16mm}R{20mm}R{15mm}R{15mm}R{15mm}R{15mm}}
      \toprule
      && \multicolumn{4}{c}{\# assets}\\
      \cmidrule{3-6}
      \# orders &                         &    5  &    10  &     20  &     50  \\
      \midrule
      100       & $ \varnothing $ runtime &  0.25 &   0.38 &    0.48 &    1.09 \\
                & \# timeouts             &     0 &      0 &       0 &       0 \\
                & -- $ \varnothing $ gap  &     - &      - &       - &       - \\
      \midrule
      200       & $ \varnothing $ runtime &  0.92 &   3.34 &    4.08 &   12.28 \\
                & \# timeouts             &     0 &      0 &       0 &       0 \\
                & -- $ \varnothing $ gap  &     - &      - &       - &       - \\
      \midrule
      500       & $ \varnothing $ runtime &  6.96 & 184.60 &  229.98 & 1398.84 \\
                & \# timeouts             &     0 &      1 &       2 &      17 \\
                & -- $ \varnothing $ gap  &     - & 3.25\% &  2.27\% &  4.85\% \\
      \bottomrule
    \end{tabular}
    \vspace{1mm}
    \caption{Disjunctive programming reformulation \eqref{eq:order_model_mip1_DP}.}
    \label{tab:results_mip1_dp}
  \end{subtable}
  \vspace{2mm}
  \caption{Computational results for MIP model I \eqref{eq:mip1}.}
  \label{tab:results_mip1}
\end{table}


\newpage
\begin{table}
  \begin{subtable}[h]{\textwidth}
    \centering
    \begin{tabular}{C{16mm}R{20mm}R{15mm}R{15mm}R{15mm}R{15mm}}
      \toprule
      && \multicolumn{4}{c}{\# assets}\\
      \cmidrule{3-6}
      \# orders &                         &     5  &    10  &    20  &    50  \\
      \midrule
      100       & $ \varnothing $ runtime &   0.44 &   0.65 &   0.54 &   0.57 \\
                & \# timeouts             &      0 &      0 &      0 &      0 \\
                & -- $ \varnothing $ gap  &      - &      - &      - &      - \\
      \midrule
      200       & $ \varnothing $ runtime &   4.14 &  18.40 &  14.27 &  20.18 \\
                & \# timeouts             &      0 &      0 &      0 &      0 \\
                & -- $ \varnothing $ gap  &      - &      - &      - &      - \\
      \midrule
      500       & $ \varnothing $ runtime & 647.98 & 646.57 & 857.77 &      - \\
                & \# timeouts             &      0 &     19 &     19 &     20 \\
                & -- $ \varnothing $ gap  &      - & 8.19\% & 6.85\% & 8.12\% \\
      \bottomrule
    \end{tabular}
    \vspace{1mm}
    \caption{Big-M reformulation.}
    \label{tab:results_mip2_bigm}
  \end{subtable}
  \par\vspace{2cm}
  \begin{subtable}[h]{\textwidth}
    \centering
    \begin{tabular}{C{16mm}R{20mm}R{15mm}R{15mm}R{15mm}R{15mm}}
      \toprule
      && \multicolumn{4}{c}{\# assets}\\
      \cmidrule{3-6}
      \# orders &                         &    5  &    10  &    20  &    50  \\
      \midrule
      100       & $ \varnothing $ runtime &  0.34 &   0.85 &   1.12 &   1.14 \\
                & \# timeouts             &     0 &      0 &      0 &      0 \\
                & -- $ \varnothing $ gap  &     - &      - &      - &      - \\
      \midrule
      200       & $ \varnothing $ runtime &  1.18 &   8.81 &  10.64 &  25.50 \\
                & \# timeouts             &     0 &      0 &      0 &      0 \\
                & -- $ \varnothing $ gap  &     - &      - &      - &      - \\
      \midrule
      500       & $ \varnothing $ runtime & 24.70 & 288.50 & 315.62 &      - \\
                & \# timeouts             &     0 &      3 &      6 &     20 \\
                & -- $ \varnothing $ gap  &     - & 2.31\% & 2.66\% & 5.39\% \\
      \bottomrule
    \end{tabular}
    \vspace{1mm}
    \caption{Disjunctive programming reformulation.}
    \label{tab:results_mip2_dp}
  \end{subtable}
  \vspace{2mm}
  \caption{Computational results for MIP model II \eqref{eq:mip2}.}
  \label{tab:results_mip2}
\end{table}


\clearpage
\section{Extensions}
\label{sec:extensions}

The problem can possibly be extended in various directions:
\begin{itemize}
  \item Basket orders: Buy/sell a set of tokens for a set of other tokens at some limit price.
  \item Automated market makers: Instead of signaling discrete demand at a specific price with one
  order, those would allow to express continues demand function over a price range.
  \item if it becomes a problem to find a valid solution \emph{at all}, the optimization problem can
  be broadened to allow violations of the current constraints but measure the violation and
  include this to the objective function.
\end{itemize}






%%%%%%%%%%%%%%%%%%%%
%%  BIBLIOGRAPHY  %%
%%%%%%%%%%%%%%%%%%%%

\newpage
\bibliographystyle{plain}
\bibliography{literature}

%\begin{thebibliography}{2}
%%
%\bibitem {balas:DP}
%Balas, E.:
%Disjunctive Programming.
%Annals of Discrete Mathematics 5, 3--51 (1979).
%\url{doi:10.1016/S0167-5060(08)70342-X}
%
%\bibitem {budish:HFT}
%Budish, E., Cramton, P., Shim, J.:
%The High-Frequency Trading Arms Race: Frequent Batch Auctions as a Market Design Response.
%The Quarterly Journal of Economics 130(4), 1547--1621 (2015)
%\url{doi:10.2139/ssrn.2388265}
%
%\bibitem {engelbrecht:multi_unit_auctions}
%Engelbrecht-Wiggans, R., Kahn, C.:
%Multi-unit auctions with uniform prices
%Economic Theory 12, 227--258 (1998), Springer-Verlag
%\url{doi:10.1007/s001990050220}
%%
%\end{thebibliography}

\end{document}